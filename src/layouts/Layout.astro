---
import "@fontsource/roboto/400.css";
import "@fontsource/roboto/500.css";
import "@fontsource/roboto/700.css";

import ConfigCarrier from "@components/ConfigCarrier.astro";
import { profileConfig, siteConfig } from "@/config";
import I18nKey from "@/i18n/i18nKey";
import { i18n } from "@/i18n/translation";
import {
  AUTO_MODE,
  BANNER_HEIGHT,
  BANNER_HEIGHT_EXTEND,
  BANNER_HEIGHT_HOME,
  DARK_MODE,
  DEFAULT_THEME,
  LIGHT_MODE,
  PAGE_WIDTH,
} from "../constants/constants";
import { defaultFavicons } from "../constants/icon";
import type { Favicon } from "../types/config";
import { asset, pathsEqual, url } from "../utils/url-utils";
import "katex/dist/katex.css";

interface Props {
  title?: string;
  banner?: string;
  description?: string;
  lang?: string;
  setOGTypeArticle?: boolean;
}

let { title, banner, description, lang, setOGTypeArticle } = Astro.props;

// apply a class to the body element to decide the height of the banner, only used for initial page load
// Swup can update the body for each page visit, but it's after the page transition, causing a delay for banner height change
// so use Swup hooks instead to change the height immediately when a link is clicked
const isHomePage = pathsEqual(Astro.url.pathname, url("/"));

// defines global css variables
// why doing this in Layout instead of GlobalStyles: https://github.com/withastro/astro/issues/6728#issuecomment-1502203757
const configHue = siteConfig.themeColor.hue;
// Respect switch: when usePostCover is true and a banner is provided by the page, use it; otherwise fallback to site default.
if (
  !siteConfig.banner.usePostCover ||
  !banner ||
  typeof banner !== "string" ||
  banner.trim() === ""
) {
  banner = siteConfig.banner.src;
}

const enableBanner = siteConfig.banner.enable;

const pageTitle = title
  ? `${title} - ${siteConfig.title}`
  : `${siteConfig.title} - ${siteConfig.subtitle}`;

const favicons: Favicon[] =
  siteConfig.favicon.length > 0 ? siteConfig.favicon : defaultFavicons;

const parseFaviconScore = (sizes?: string) => {
  if (!sizes) return 0;
  const [w, h] = sizes.split("x").map((value) => Number.parseInt(value, 10));
  if (!Number.isFinite(w)) return 0;
  if (!Number.isFinite(h)) return w * w;
  return w * h;
};

const selectLargestFavicon = (icons: Favicon[]) => {
  return icons
    .map((icon) => ({ icon, score: parseFaviconScore(icon.sizes) }))
    .sort((a, b) => b.score - a.score)[0]?.icon;
};

const loaderFaviconNeutral =
  selectLargestFavicon(favicons.filter((icon) => !icon.theme)) ||
  selectLargestFavicon(favicons) ||
  favicons[0];
const loaderFaviconLight = selectLargestFavicon(
  favicons.filter((icon) => icon.theme === "light")
);
const loaderFaviconDark = selectLargestFavicon(
  favicons.filter((icon) => icon.theme === "dark")
);

// const siteLang = siteConfig.lang.replace('_', '-')
if (!lang) {
  lang = `${siteConfig.lang}`;
}
const siteLang = lang.replace("_", "-");

const bannerOffsetByPosition = {
  top: `${BANNER_HEIGHT_EXTEND}vh`,
  center: `${BANNER_HEIGHT_EXTEND / 2}vh`,
  bottom: "0",
};
const bannerOffset =
  bannerOffsetByPosition[siteConfig.banner.position || "center"];
---

<!doctype html>
<html
  lang={siteLang}
  class="bg-[var(--page-bg)] transition text-[14px] md:text-[16px]"
  data-overlayscrollbars-initialize
  data-cold-start="true"
>
  <head>
    <title>{pageTitle}</title>

    <meta charset="UTF-8" />
    <meta name="description" content={description || pageTitle} />
    <meta name="author" content={profileConfig.name} />

    <meta property="og:site_name" content={siteConfig.title} />
    <meta property="og:url" content={Astro.url} />
    <meta property="og:title" content={pageTitle} />
    <meta property="og:description" content={description || pageTitle} />
    {
      setOGTypeArticle ? (
        <meta property="og:type" content="article" />
      ) : (
        <meta property="og:type" content="website" />
      )
    }

    <meta name="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content={Astro.url} />
    <meta name="twitter:title" content={pageTitle} />
    <meta name="twitter:description" content={description || pageTitle} />

    <meta name="viewport" content="width=device-width" />
    <meta name="generator" content={Astro.generator} />
    {
      favicons.map((favicon) => (
        <link
          rel="icon"
          href={favicon.src.startsWith("/") ? asset(favicon.src) : favicon.src}
          sizes={favicon.sizes}
          media={favicon.theme && `(prefers-color-scheme: ${favicon.theme})`}
        />
      ))
    }

    <!-- Set the theme before the page is rendered to avoid a flash -->
    <script
      is:inline
      define:vars={{
        DEFAULT_THEME,
        LIGHT_MODE,
        DARK_MODE,
        AUTO_MODE,
        BANNER_HEIGHT_EXTEND,
        PAGE_WIDTH,
        configHue,
      }}
    >
      // Load the theme from local storage
      const theme = localStorage.getItem("theme") || DEFAULT_THEME;
      switch (theme) {
        case LIGHT_MODE:
          document.documentElement.classList.remove("dark");
          break;
        case DARK_MODE:
          document.documentElement.classList.add("dark");
          break;
        case AUTO_MODE:
          if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
            document.documentElement.classList.add("dark");
          } else {
            document.documentElement.classList.remove("dark");
          }
      }

      // Load the hue from local storage
      const hue = localStorage.getItem("hue") || configHue;
      document.documentElement.style.setProperty("--hue", hue);

      // calculate the --banner-height-extend, which needs to be a multiple of 4 to avoid blurry text
      let offset = Math.floor(
        window.innerHeight * (BANNER_HEIGHT_EXTEND / 100)
      );
      offset = offset - (offset % 4);
      document.documentElement.style.setProperty(
        "--banner-height-extend",
        `${offset}px`
      );
    </script>
    <style
      define:vars={{
        configHue,
        "page-width": `${PAGE_WIDTH}rem`,
      }}
    ></style>
    <script is:inline>
      (() => {
        const docEl = document.documentElement;

        const hasSessionWarm = (() => {
          try {
            return sessionStorage.getItem("appWarm") === "1";
          } catch (error) {
            return false;
          }
        })();

        const isReloadNavigation = (() => {
          const navEntry = performance?.getEntriesByType?.("navigation")?.[0];
          if (navEntry && "type" in navEntry) {
            return navEntry.type === "reload";
          }

          const legacyNavKey = ["navigation"];
          const legacyTypeKey = ["type"];
          const legacyReloadKey = ["TYPE_RELOAD"];

          const legacyNav = globalThis?.["performance"]?.[legacyNavKey[0]];
          if (!legacyNav) {
            return false;
          }
          const legacyType = legacyNav?.[legacyTypeKey[0]];
          const legacyReloadConstant = legacyNav?.[legacyReloadKey[0]];
          return legacyType === legacyReloadConstant || legacyType === 1;
        })();

        const shouldSkipLoader = hasSessionWarm && !isReloadNavigation;
        docEl.dataset.coldStart = shouldSkipLoader ? "false" : "true";
        if (shouldSkipLoader) {
          docEl.classList.add("cold-start-complete");
        }
      })();
    </script>
    <!-- defines global css variables. This will be applied to <html> <body> and some other elements idk why -->

    <slot name="head" />

    <link
      rel="alternate"
      type="application/rss+xml"
      title={profileConfig.name}
      href={`${Astro.site}rss.xml`}
    />
    <script type="text/javascript" is:inline>
      (function (
        windowObj,
        documentObj,
        clarityKey,
        scriptTag,
        clarityId,
        scriptElem,
        firstScript
      ) {
        windowObj[clarityKey] =
          windowObj[clarityKey] ||
          function () {
            (windowObj[clarityKey].q = windowObj[clarityKey].q || []).push(
              arguments
            );
          };
        scriptElem = documentObj.createElement(scriptTag);
        scriptElem.async = 1;
        scriptElem.src = "https://www.clarity.ms/tag/" + clarityId;
        firstScript = documentObj.getElementsByTagName(scriptTag)[0];
        firstScript.parentNode.insertBefore(scriptElem, firstScript);
      })(window, document, "clarity", "script", "tlcnbxjj3p");
    </script>
  </head>
  <body
    class="min-h-screen transition"
    class:list={[{ "lg:is-home": isHomePage, "enable-banner": enableBanner }]}
    data-overlayscrollbars-initialize
  >
    <ConfigCarrier />
    <div
      id="cold-start-loader"
      role="status"
      aria-live="polite"
      aria-busy="true"
    >
      <div class="loader-panel">
        <div class="loader-header">
          <div class="loader-symbol" aria-hidden="true">
            <picture>
              {
                loaderFaviconDark && (
                  <source
                    srcset={loaderFaviconDark.src}
                    media="(prefers-color-scheme: dark)"
                  />
                )
              }
              {
                loaderFaviconLight && (
                  <source
                    srcset={loaderFaviconLight.src}
                    media="(prefers-color-scheme: light)"
                  />
                )
              }
              <img
                src={loaderFaviconNeutral?.src}
                alt=""
                width="52"
                height="52"
                loading="eager"
                decoding="async"
              />
            </picture>
          </div>
          <div class="loader-meta">
            <p class="loader-label">{siteConfig.title}</p>
            <p class="loader-status">{i18n(I18nKey.initialLoading)}</p>
          </div>
        </div>
        <div class="loader-progress" data-progress>
          <span class="loader-bar"></span>
        </div>
      </div>
    </div>
    <slot />

    <!-- increase the page height during page transition to prevent the scrolling animation from jumping -->
    <div id="page-height-extend" class="hidden h-[300vh]"></div>
  </body>
</html>

<style
  is:global
  define:vars={{
    bannerOffset,
    "banner-height-home": `${BANNER_HEIGHT_HOME}vh`,
    "banner-height": `${BANNER_HEIGHT}vh`,
  }}
>
  @tailwind components;
  @layer components {
    .enable-banner.is-home #banner-wrapper {
      @apply h-[var(--banner-height-home)] translate-y-[var(--banner-height-extend)];
    }
    .enable-banner #banner-wrapper {
      @apply h-[var(--banner-height-home)];
    }

    .enable-banner.is-home #banner {
      @apply h-[var(--banner-height-home)] translate-y-0;
    }
    .enable-banner #banner {
      @apply h-[var(--banner-height-home)] translate-y-[var(--bannerOffset)];
    }
    .enable-banner.is-home #main-grid {
      @apply translate-y-[var(--banner-height-extend)];
    }
    .enable-banner #top-row {
      @apply h-[calc(var(--banner-height-home)_-_4.5rem)] transition-all duration-300;
    }
    .enable-banner.is-home #sidebar-sticky {
      @apply top-[calc(1rem_-_var(--banner-height-extend))];
    }
    .navbar-hidden {
      @apply opacity-0 -translate-y-16;
    }
  }

  #cold-start-loader {
    --loader-primary: hsl(var(--hue, 210) 65% 52%);
    --loader-on-primary: #ffffff;
    --loader-track: color-mix(in srgb, var(--loader-primary) 18%, transparent);
    --loader-surface: color-mix(
      in srgb,
      var(--page-bg, #ffffff) 96%,
      #000000 4%
    );
    --loader-outline: color-mix(
      in srgb,
      var(--loader-primary) 32%,
      transparent
    );
    --loader-text: color-mix(in srgb, #111111 75%, var(--loader-primary) 25%);
    --loader-subtext: color-mix(in srgb, var(--loader-text) 60%, transparent);
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 1.5rem;
    z-index: 9999;
    background: color-mix(in srgb, var(--page-bg, #fff) 92%, #000 8%);
    backdrop-filter: blur(4px);
    opacity: 0;
    pointer-events: none;
    transition: opacity 200ms ease;
  }

  html[data-cold-start="true"] #cold-start-loader {
    opacity: 1;
    pointer-events: auto;
  }

  #cold-start-loader.cold-start-loader--done {
    opacity: 0;
    pointer-events: none;
  }

  #cold-start-loader .loader-panel {
    width: min(380px, calc(100% - 2.25rem));
    margin: 0 auto;
    padding: 1.5rem;
    border-radius: 0.85rem;
    background: var(--loader-surface);
    border: 1px solid var(--loader-outline);
    box-shadow: 0 18px 45px rgb(0 0 0 / 0.12);
    color: var(--loader-text);
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  html.dark #cold-start-loader {
    --loader-surface: color-mix(
      in srgb,
      #101418 88%,
      var(--loader-primary) 12%
    );
    --loader-outline: color-mix(
      in srgb,
      var(--loader-primary) 45%,
      #000000 35%
    );
    --loader-text: color-mix(in srgb, #f5f5f5 85%, var(--loader-primary) 15%);
    --loader-subtext: color-mix(in srgb, var(--loader-text) 70%, transparent);
  }

  html.dark #cold-start-loader .loader-panel {
    box-shadow: 0 26px 60px rgb(0 0 0 / 0.5);
  }

  #cold-start-loader .loader-header {
    display: grid;
    grid-template-columns: auto 1fr;
    align-items: center;
    gap: 1rem;
  }

  #cold-start-loader .loader-symbol {
    width: 68px;
    height: 68px;
    border-radius: 0.75rem;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
  }

  #cold-start-loader .loader-symbol picture,
  #cold-start-loader .loader-symbol img {
    display: block;
    width: 60px;
    height: 60px;
    border-radius: 0.65rem;
  }

  #cold-start-loader .loader-symbol img {
    object-fit: contain;
    background: none;
    padding: 0;
  }

  #cold-start-loader .loader-meta {
    display: flex;
    flex-direction: column;
    gap: 0.4rem;
  }

  #cold-start-loader .loader-label {
    margin: 0;
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--loader-text);
  }

  #cold-start-loader .loader-status {
    margin: 0;
    font-size: 0.95rem;
    color: var(--loader-subtext);
  }

  #cold-start-loader .loader-progress {
    --cold-progress: 0%;
    position: relative;
    width: 100%;
    height: 0.6rem;
    border-radius: 999px;
    background: var(--loader-track);
    overflow: hidden;
  }

  #cold-start-loader .loader-bar {
    position: absolute;
    inset: 0;
    width: var(--cold-progress);
    border-radius: inherit;
    background-image: linear-gradient(
      90deg,
      color-mix(in srgb, var(--loader-primary), #ffffff 12%),
      color-mix(in srgb, var(--loader-primary), #000000 10%)
    );
    transition: width 250ms cubic-bezier(0.4, 0, 0.2, 1);
    will-change: width;
  }
</style>

<script>
  import "overlayscrollbars/overlayscrollbars.css";
  import {
    OverlayScrollbars,
    // ScrollbarsHidingPlugin,
    // SizeObserverPlugin,
    // ClickScrollPlugin
  } from "overlayscrollbars";
  import {
    getHue,
    getStoredTheme,
    setHue,
    setTheme,
  } from "../utils/setting-utils";
  import { pathsEqual, url } from "../utils/url-utils";
  import {
    BANNER_HEIGHT,
    BANNER_HEIGHT_HOME,
    BANNER_HEIGHT_EXTEND,
    MAIN_PANEL_OVERLAPS_BANNER_HEIGHT,
  } from "../constants/constants";
  import { siteConfig } from "../config";

  /* Preload fonts */
  // (async function() {
  // 	try {
  // 		await Promise.all([
  // 			document.fonts.load("400 1em Roboto"),
  // 			document.fonts.load("700 1em Roboto"),
  // 		]);
  // 		document.body.classList.remove("hidden");
  // 	} catch (error) {
  // 		console.log("Failed to load fonts:", error);
  // 	}
  // })();

  /* TODO This is a temporary solution for style flicker issue when the transition is activated */
  /* issue link: https://github.com/withastro/astro/issues/8711, the solution get from here too */
  /* update: fixed in Astro 3.2.4 */
  /*
function disableAnimation() {
	const css = document.createElement('style')
	css.appendChild(
		document.createTextNode(
			`*{
              -webkit-transition:none!important;
              -moz-transition:none!important;
              -o-transition:none!important;
              -ms-transition:none!important;
              transition:none!important
              }`
		)
	)
	document.head.appendChild(css)

	return () => {
		// Force restyle
		;(() => window.getComputedStyle(document.body))()

		// Wait for next tick before removing
		setTimeout(() => {
			document.head.removeChild(css)
		}, 1)
	}
}
*/

  const bannerEnabled = !!document.getElementById("banner-wrapper");

  // Show a cold-start progress overlay once per browser tab session.
  (function setupColdStartLoader() {
    const html = document.documentElement;
    const loader = document.getElementById("cold-start-loader");
    if (!loader || html.dataset.coldStart !== "true") {
      return;
    }

    const progressTrack = loader.querySelector(
      "[data-progress]"
    ) as HTMLElement | null;
    let progressValue = 0;
    const setProgress = (value: number) => {
      progressValue = value;
      if (progressTrack) {
        progressTrack.style.setProperty("--cold-progress", `${value}%`);
      }
    };

    let totalResources = 0;
    let loadedResources = 0;
    let domLoadProgress = 0;
    let fallbackTimer: number | undefined;

    const countResources = () => {
      const images = document.images.length;
      const scripts = document.scripts.length;
      const links = document.querySelectorAll('link[rel="stylesheet"]').length;
      return Math.max(images + scripts + links, 1);
    };

    const updateProgress = () => {
      const resourceProgress =
        totalResources > 0 ? (loadedResources / totalResources) * 70 : 0;
      const totalProgress = Math.min(domLoadProgress + resourceProgress, 98);
      setProgress(totalProgress);
    };

    const trackResourceLoading = () => {
      totalResources = countResources();

      Array.from(document.images).forEach((img) => {
        if (img.complete) {
          loadedResources++;
        } else {
          const onLoad = () => {
            loadedResources++;
            updateProgress();
            img.removeEventListener("load", onLoad);
            img.removeEventListener("error", onLoad);
          };
          img.addEventListener("load", onLoad);
          img.addEventListener("error", onLoad);
        }
      });

      Array.from(document.querySelectorAll('link[rel="stylesheet"]')).forEach(
        (link) => {
          const linkEl = link as HTMLLinkElement;
          if (linkEl.sheet) {
            loadedResources++;
          } else {
            const onLoad = () => {
              loadedResources++;
              updateProgress();
              linkEl.removeEventListener("load", onLoad);
              linkEl.removeEventListener("error", onLoad);
            };
            linkEl.addEventListener("load", onLoad);
            linkEl.addEventListener("error", onLoad);
          }
        }
      );

      loadedResources += document.scripts.length;
      updateProgress();
    };

    if (document.readyState === "loading") {
      domLoadProgress = 10;
      setProgress(10);

      document.addEventListener(
        "DOMContentLoaded",
        () => {
          domLoadProgress = 30;
          trackResourceLoading();
          updateProgress();
        },
        { once: true }
      );
    } else if (document.readyState === "interactive") {
      domLoadProgress = 30;
      setProgress(30);
      trackResourceLoading();
      updateProgress();
    } else {
      domLoadProgress = 30;
      trackResourceLoading();
      updateProgress();
    }

    const finalize = () => {
      if (fallbackTimer !== undefined) {
        clearTimeout(fallbackTimer);
      }
      setProgress(100);
      loader.classList.add("cold-start-loader--done");
      html.dataset.coldStart = "false";
      html.classList.add("cold-start-complete");
      try {
        sessionStorage.setItem("appWarm", "1");
      } catch (error) {
        /* ignore */
      }
      window.setTimeout(() => loader.remove(), 320);
    };

    const enableDebugHold =
      window.location.search.includes("debugColdLoader=true") ||
      window.location.hash.includes("debug-cold-loader");

    if (enableDebugHold) {
      setProgress(64);
      loader.setAttribute("data-debug", "true");
      html.dataset.coldStart = "true";
      try {
        sessionStorage.removeItem("appWarm");
      } catch (error) {
        /* ignore */
      }
      (
        window as typeof window & {
          __resumeColdLoader?: () => void;
        }
      ).__resumeColdLoader = () => {
        finalize();
      };
      return;
    }

    if (document.readyState === "complete") {
      finalize();
    } else {
      window.addEventListener("load", finalize, { once: true });

      fallbackTimer = window.setTimeout(() => {
        if (progressValue < 98) {
          console.warn("[Loader] Forcing completion due to timeout");
        }
        finalize();
      }, 8000);
    }
  })();

  function setClickOutsideToClose(
    panel: string,
    ignores: string[],
    toggles: string[] = []
  ) {
    document.addEventListener("click", (event) => {
      const target = event.target;
      if (!(target instanceof Node)) return;

      // Check if click is inside ignored elements
      if (
        ignores.some((id) => {
          const el = document.getElementById(id);
          return el === target || el?.contains(target);
        })
      )
        return;

      // Close panel and update toggles
      const panelDom = document.getElementById(panel);
      panelDom?.classList.add("float-panel-closed");

      toggles.forEach((id) => {
        document.getElementById(id)?.setAttribute("aria-expanded", "false");
      });
    });
  }
  setClickOutsideToClose(
    "display-setting",
    ["display-setting", "display-settings-switch"],
    ["display-settings-switch"]
  );
  setClickOutsideToClose("search-panel", [
    "search-panel",
    "search-bar",
    "search-switch",
  ]);

  function loadTheme() {
    const theme = getStoredTheme();
    setTheme(theme);
  }

  function loadHue() {
    setHue(getHue());
  }

  // Initialize OverlayScrollbars with guards to avoid duplicate init on body
  function initCustomScrollbar() {
    const bodyElement = document.querySelector("body");
    if (!bodyElement) return;
    // @ts-ignore runtime guard for repeated init across swaps
    if (window.__osBody) return;
    const instance = OverlayScrollbars(
      {
        // Initializing on <body> can affect native APIs according to docs; we opt-in for consistent styling
        target: bodyElement,
        cancel: {
          nativeScrollbarsOverlaid: true, // skip when native overlay scrollbars are present
        },
      },
      {
        scrollbars: {
          theme: "scrollbar-base scrollbar-auto py-1",
          autoHide: "move",
          autoHideDelay: 500,
          autoHideSuspend: false,
        },
      }
    );
    // @ts-ignore store instance on window to prevent duplicates
    window.__osBody = instance;

    const katexElements = document.querySelectorAll(
      ".katex-display"
    ) as NodeListOf<HTMLElement>;

    const katexObserverOptions = {
      root: null,
      rootMargin: "100px",
      threshold: 0.1,
    };

    const processKatexElement = (element: HTMLElement) => {
      if (!element.parentNode) return;
      if (element.hasAttribute("data-scrollbar-initialized")) return;

      const container = document.createElement("div");
      container.className = "katex-display-container";
      container.setAttribute("aria-label", "scrollable container for formulas");

      element.parentNode.insertBefore(container, element);
      container.appendChild(element);

      OverlayScrollbars(container, {
        scrollbars: {
          theme: "scrollbar-base scrollbar-auto",
          autoHide: "leave",
          autoHideDelay: 500,
          autoHideSuspend: false,
        },
      });

      element.setAttribute("data-scrollbar-initialized", "true");
    };

    const katexObserver = new IntersectionObserver((entries, observer) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          processKatexElement(entry.target as HTMLElement);
          observer.unobserve(entry.target);
        }
      });
    }, katexObserverOptions);

    katexElements.forEach((element) => {
      katexObserver.observe(element);
    });
  }

  function showBanner() {
    if (!siteConfig.banner.enable) return;

    const banner = document.getElementById("banner");
    if (!banner) {
      console.error("Banner element not found");
      return;
    }

    banner.classList.remove("opacity-0", "scale-105");
  }

  function init() {
    // disableAnimation()()		// TODO
    loadTheme();
    loadHue();
    showBanner();

    // Defer scrollbar initialization until after Svelte components hydrate
    // This prevents conflicts with Svelte component initialization
    if ("requestIdleCallback" in window) {
      // @ts-ignore
      window.requestIdleCallback(() => initCustomScrollbar(), {
        timeout: 2000,
      });
    } else {
      setTimeout(initCustomScrollbar, 500);
    }
  }

  /* Load settings when entering the site */
  init();

  const setup = () => {
    // TODO: temp solution to change the height of the banner
    /*
	window.swup.hooks.on('animation:out:start', () => {
		const path = window.location.pathname
		const body = document.querySelector('body')
		if (path[path.length - 1] === '/' && !body.classList.contains('is-home')) {
			body.classList.add('is-home')
		} else if (path[path.length - 1] !== '/' && body.classList.contains('is-home')) {
			body.classList.remove('is-home')
		}
	})
*/
    window.swup.hooks.on("link:click", () => {
      document.documentElement.style.setProperty("--content-delay", "0ms");

      // Prevent navbar overlap on home page with banner
      if (!bannerEnabled) return;

      const threshold = window.innerHeight * (BANNER_HEIGHT / 100) - 72 - 16;
      const navbar = document.getElementById("navbar-wrapper");
      const isHomePage = document.body.classList.contains("lg:is-home");

      if (navbar && isHomePage) {
        const currentScroll =
          window.scrollY || document.documentElement.scrollTop || 0;
        if (currentScroll >= threshold) {
          navbar.classList.add("navbar-hidden");
        }
      }
    });

    // Hook: animation:out:start - Triggered when fade-out animation begins
    window.swup.hooks.on("animation:out:start", () => {
      // Smooth scroll to top during fade-out for seamless transition
      window.scrollTo({ top: 0, behavior: "smooth" });

      // Reset navbar state to prevent it from being stuck hidden
      // This fixes same-page navigation (e.g., clicking home while on home)
      const navbar = document.getElementById("navbar-wrapper");
      if (navbar) {
        navbar.classList.remove("navbar-hidden");
        navbarIsHidden = false;
      }
    });

    // Hook: visit:start - Triggered when navigation begins
    window.swup.hooks.on("visit:start", (visit: { to: { url: string } }) => {
      const bodyElement = document.querySelector("body");
      const isGoingToHome = pathsEqual(visit.to.url, url("/"));

      // Update body class for banner height adjustment
      bodyElement?.classList.toggle("lg:is-home", isGoingToHome);

      // Recalculate cached values based on new layout
      updateCachedValues();

      // Show height extension element to prevent scroll jump during transition
      const heightExtend = document.getElementById("page-height-extend");
      heightExtend?.classList.remove("hidden");

      // Hide TOC during scroll animation
      const toc = document.getElementById("toc-wrapper");
      toc?.classList.add("toc-not-ready");
    });

    // Hook: content:replace - Triggered after DOM content is replaced
    window.swup.hooks.on("content:replace", () => {
      // Defer scrollbar initialization to avoid conflicts with Svelte component hydration
      const initScrollbars = () => initCustomScrollbar();

      if ("requestIdleCallback" in window) {
        // @ts-ignore - Wait for idle time with 2s timeout
        window.requestIdleCallback(initScrollbars, { timeout: 2000 });
      } else {
        setTimeout(initScrollbars, 500);
      }
    });

    // Hook: page:view - Triggered when new page is visible
    window.swup.hooks.on("page:view", () => {
      // Hide height extension element
      const heightExtend = document.getElementById("page-height-extend");
      heightExtend?.classList.add("hidden");

      // Ensure navbar is visible on new page (backup safety)
      const navbar = document.getElementById("navbar-wrapper");
      if (navbar) {
        navbar.classList.remove("navbar-hidden");
        navbarIsHidden = false;
      }

      // Update scroll tracking for the new page
      lastScrollY = window.scrollY || document.documentElement.scrollTop || 0;
      if (!scrollScheduled) {
        scrollScheduled = true;
        requestAnimationFrame(processScroll);
      }
    });

    // Hook: visit:end - Triggered when navigation is complete
    window.swup.hooks.on("visit:end", () => {
      setTimeout(() => {
        // Final cleanup: ensure height extension is hidden
        const heightExtend = document.getElementById("page-height-extend");
        heightExtend?.classList.add("hidden");

        // Show TOC after transition completes
        const toc = document.getElementById("toc-wrapper");
        toc?.classList.remove("toc-not-ready");
      }, 200);
    });
  };
  if (window?.swup?.hooks) {
    setup();
  } else {
    document.addEventListener("swup:enable", setup);
  }

  const NAVBAR_HEIGHT_PX = 72;
  const REM_TO_PX = 16;
  const LARGE_SCREEN_BREAKPOINT = 1024;

  // DOM element references (cached for performance)
  let backToTopBtn = document.getElementById("back-to-top-btn");
  let toc = document.getElementById("toc-wrapper");
  let navbar = document.getElementById("navbar-wrapper");

  // Scroll state tracking
  let scrollScheduled = false;
  let lastScrollY = 0;

  // Component visibility state (prevents redundant DOM updates)
  let backToTopVisible = false;
  let tocVisible = false;
  let navbarIsHidden = false;

  // Cached computed values (avoid repeated calculations)
  let cachedBannerHeightPx = 0;
  let cachedNavbarThreshold = 0;
  let cachedViewportWidth = window.innerWidth;

  function updateCachedValues() {
    cachedBannerHeightPx = window.innerHeight * (BANNER_HEIGHT / 100);

    const mainPanelOverlap = MAIN_PANEL_OVERLAPS_BANNER_HEIGHT * REM_TO_PX;
    const isHomePage = document.body.classList.contains("lg:is-home");
    const isLargeScreen = cachedViewportWidth >= LARGE_SCREEN_BREAKPOINT;

    const bannerHeight =
      isHomePage && isLargeScreen ? BANNER_HEIGHT_HOME : BANNER_HEIGHT;

    cachedNavbarThreshold =
      window.innerHeight * (bannerHeight / 100) -
      NAVBAR_HEIGHT_PX -
      mainPanelOverlap -
      REM_TO_PX;
  }

  updateCachedValues();

  /**
   * Process scroll events with optimized DOM batching
   * Read Phase: Gather all scroll position data
   * Calculate Phase: Determine visibility states
   * Write Phase: Apply all DOM changes together
   * This pattern minimizes forced reflows and improves performance
   */
  function processScroll() {
    scrollScheduled = false;
    const scrollY = lastScrollY;

    // ========== READ PHASE: Check DOM element availability ==========
    const hasBackToTop = !!backToTopBtn;
    const hasToc = bannerEnabled && !!toc;
    const hasNavbar = bannerEnabled && !!navbar;

    const shouldShowBackToTop = hasBackToTop && scrollY > cachedBannerHeightPx;
    const shouldShowToc = hasToc && scrollY > cachedBannerHeightPx;
    const shouldHideNavbar = hasNavbar && scrollY >= cachedNavbarThreshold;

    if (hasBackToTop && shouldShowBackToTop !== backToTopVisible) {
      backToTopVisible = shouldShowBackToTop;
      backToTopBtn!.classList.toggle("hide", !shouldShowBackToTop);
    }

    if (hasToc && shouldShowToc !== tocVisible) {
      tocVisible = shouldShowToc;
      toc!.classList.toggle("toc-hide", !shouldShowToc);
    }

    if (hasNavbar && shouldHideNavbar !== navbarIsHidden) {
      navbarIsHidden = shouldHideNavbar;
      navbar!.classList.toggle("navbar-hidden", shouldHideNavbar);
    }
  }

  function onScroll() {
    // Cache current scroll position (cross-browser compatible)
    lastScrollY =
      window.scrollY ||
      document.documentElement.scrollTop ||
      document.body.scrollTop ||
      0;

    // Throttle: only schedule one update per frame
    if (!scrollScheduled) {
      scrollScheduled = true;
      requestAnimationFrame(processScroll);
    }
  }

  window.addEventListener("scroll", onScroll, { passive: true });

  let resizeScheduled = false;

  function processResize() {
    resizeScheduled = false;
    cachedViewportWidth = window.innerWidth;

    // Calculate banner-height-extend (must be multiple of 4 to avoid blurry text)
    let offset = Math.floor(window.innerHeight * (BANNER_HEIGHT_EXTEND / 100));
    offset = offset - (offset % 4);
    document.documentElement.style.setProperty(
      "--banner-height-extend",
      `${offset}px`
    );

    // Recalculate all cached layout values
    updateCachedValues();

    // Trigger scroll recalculation for new viewport
    onScroll();
  }

  /**
   * Throttled resize event handler using requestAnimationFrame
   */
  function onResize() {
    if (!resizeScheduled) {
      resizeScheduled = true;
      requestAnimationFrame(processResize);
    }
  }

  window.addEventListener("resize", onResize, { passive: true });
</script>

<script>
  import PhotoSwipeLightbox from "photoswipe/lightbox";
  import "photoswipe/style.css";

  let lightbox: PhotoSwipeLightbox;
  let pswp = import("photoswipe");

  function createPhotoSwipe() {
    lightbox = new PhotoSwipeLightbox({
      gallery: ".custom-md img, #post-cover img",
      pswpModule: () => pswp,
      closeSVG:
        '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#ffffff"><path d="M480-424 284-228q-11 11-28 11t-28-11q-11-11-11-28t11-28l196-196-196-196q-11-11-11-28t11-28q11-11 28-11t28 11l196 196 196-196q11-11 28-11t28 11q11 11 11 28t-11 28L536-480l196 196q11 11 11 28t-11 28q-11 11-28 11t-28-11L480-424Z"/></svg>',
      zoomSVG:
        '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#ffffff"><path d="M340-540h-40q-17 0-28.5-11.5T260-580q0-17 11.5-28.5T300-620h40v-40q0-17 11.5-28.5T380-700q17 0 28.5 11.5T420-660v40h40q17 0 28.5 11.5T500-580q0 17-11.5 28.5T460-540h-40v40q0 17-11.5 28.5T380-460q-17 0-28.5-11.5T340-500v-40Zm40 220q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l224 224q11 11 11 28t-11 28q-11 11-28 11t-28-11L532-372q-30 24-69 38t-83 14Zm0-80q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg>',
      padding: { top: 20, bottom: 20, left: 20, right: 20 },
      wheelToZoom: true,
      arrowPrev: false,
      arrowNext: false,
      imageClickAction: "close",
      tapAction: "close",
      doubleTapAction: "zoom",
    });

    lightbox.addFilter("domItemData", (itemData, element) => {
      if (element instanceof HTMLImageElement) {
        itemData.src = element.src;

        itemData.w = Number(element.naturalWidth || window.innerWidth);
        itemData.h = Number(element.naturalHeight || window.innerHeight);

        itemData.msrc = element.src;
      }

      return itemData;
    });

    lightbox.init();
  }

  const setup = () => {
    // On-demand bootstrap: initialize lightbox upon first user click on an eligible image
    const selector = ".custom-md img, #post-cover img";
    const bootstrapOnFirstClick = (ev: Event) => {
      const target = ev.target as Element | null;
      if (!target) return;
      if (!(target instanceof Element)) return;
      if (!target.matches(selector)) return;
      if (lightbox) return; // already ready
      ev.preventDefault();
      const again = () => (target as HTMLElement).click();
      const run = () => {
        if (!lightbox) createPhotoSwipe();
        // allow PhotoSwipe to attach listeners, then replay click
        setTimeout(again, 0);
        document.removeEventListener("click", bootstrapOnFirstClick, true);
      };
      if ("requestIdleCallback" in window) {
        // @ts-ignore
        window.requestIdleCallback(run, { timeout: 500 });
      } else {
        setTimeout(run, 0);
      }
    };
    document.addEventListener("click", bootstrapOnFirstClick, {
      capture: true,
    });

    window.swup.hooks.on("page:view", () => {
      // Keep the bootstrap listener active across views
    });

    window.swup.hooks.on(
      "content:replace",
      () => {
        lightbox?.destroy?.();
        // reset so next page can schedule lazily again
        // @ts-ignore
        lightbox = undefined;
      },
      { before: true }
    );
  };

  if (window.swup) {
    setup();
  } else {
    document.addEventListener("swup:enable", setup);
  }
</script>
