---
import { Icon } from "astro-icon/components";
import I18nKey from "../../i18n/i18nKey";
import { i18n } from "../../i18n/translation";
import { type NavBarLink } from "../../types/config";
import { url } from "../../utils/url-utils";
import Categories from "./Categories.astro";
import Profile from "./Profile.astro";
import Tags from "./Tags.astro";

interface Props {
  links: NavBarLink[];
}

const links = Astro.props.links;
---

<div
  id="nav-menu-overlay"
  aria-hidden="true"
  inert
  class="fixed inset-0 bg-black/50 backdrop-blur-sm md:hidden"
>
</div>

<div
  id="nav-menu-panel"
  aria-hidden="true"
  inert
  class="card-base float-panel-acrylic fixed top-0 left-0 h-full shadow-2xl border-l border-[var(--line-divider)] overflow-y-auto overflow-x-hidden md:hidden"
>
  <div class="flex flex-col h-full">
    <div id="nav-menu-content" class="flex-1 overflow-y-auto p-4">
      <div class="lg:hidden flex flex-col gap-4">
        <Profile />
        <div class="border-t border-[var(--line-divider)] mb-4"></div>
        <div class="flex flex-col gap-2 mb-6">
          {
            links.map((link) => (
              <a
                href={link.external ? link.url : url(link.url)}
                class="nav-link group flex justify-between items-center py-3 ps-5 pe-4 rounded-xl gap-4 transition-all"
                target={link.external ? "_blank" : null}
              >
                <div class="transition text-black/75 dark:text-white/75 font-medium group-hover:text-[var(--primary)] group-active:text-[var(--primary)]">
                  {link.name}
                </div>
                <div class="flex items-center gap-2">
                  {!link.external && (
                    <Icon
                      name="material-symbols:chevron-right-rounded"
                      class="transition text-[1.25rem] text-[var(--primary)] group-hover:translate-x-1"
                    />
                  )}
                  {link.external && (
                    <Icon
                      name="fa6-solid:arrow-up-right-from-square"
                      class="transition text-[0.75rem] text-black/25 dark:text-white/25"
                    />
                  )}
                </div>
              </a>
            ))
          }
          <!-- Settings link in mobile menu -->
          <a
            href={url("/settings")}
            class="nav-link group flex justify-between items-center py-3 ps-5 pe-4 rounded-xl gap-4 transition-all"
          >
            <div
              class="transition text-black/75 dark:text-white/75 font-medium group-hover:text-[var(--primary)] group-active:text-[var(--primary)] flex items-center gap-2"
            >
              <Icon
                name="material-symbols:settings-outline-rounded"
                class="text-[1.25rem]"
              />
              {i18n(I18nKey.settings)}
            </div>
            <div class="flex items-center gap-2">
              <Icon
                name="material-symbols:chevron-right-rounded"
                class="transition text-[1.25rem] text-[var(--primary)] group-hover:translate-x-1"
              />
            </div>
          </a>
        </div>
        <Categories />
        <Tags />
      </div>
    </div>
  </div>
</div>

<div
  id="nav-menu-popover"
  aria-hidden="true"
  inert
  class="card-base float-panel-acrylic hidden md:block lg:hidden fixed top-[5.25rem] right-4 w-[22rem] max-w-[calc(100vw_-_2rem)] max-h-[calc(100vh_-_6rem)] rounded-2xl border border-[var(--line-divider)] shadow-2xl overflow-y-auto scrollbar-hide"
>
  <div class="p-4 flex flex-col gap-4">
    <Profile />
    <Categories />
    <Tags />
  </div>
</div>

<script>
  type NavMenuAction = "open" | "close";
  type ViewportMode = "mobile" | "medium" | "desktop";
  type Surface = "sidebar" | "popover";

  declare global {
    interface Window {
      openNavMenu?: () => void;
      closeNavMenu?: () => void;
      __navMenuPending?: NavMenuAction | null;
      __navMenuController?: NavMenuController;
      __navMenuSwupAttached?: boolean;
    }
  }

  class NavMenuController {
    private overlayEl: HTMLElement;
    private panelEl: HTMLElement;
    private popoverEl: HTMLElement;
    private triggerEl: HTMLElement | null;
    private abortController: AbortController;
    private mode: ViewportMode;
    private activeSurface: Surface | null = null;
    private scrollThrottleTimer: number | null = null;
    private resizeDebounceTimer: number | null = null;

    private readonly BREAKPOINT_MD = 768;
    private readonly BREAKPOINT_LG = 1024;

    constructor() {
      const overlay = document.getElementById("nav-menu-overlay");
      const panel = document.getElementById("nav-menu-panel");
      const popover = document.getElementById("nav-menu-popover");

      if (!overlay || !panel || !popover) {
        throw new Error("Required nav menu elements not found");
      }

      this.overlayEl = overlay as HTMLElement;
      this.panelEl = panel as HTMLElement;
      this.popoverEl = popover as HTMLElement;
      this.triggerEl = document.getElementById("nav-menu-switch");
      this.abortController = new AbortController();
      this.mode = this.getViewportMode();
      this.scrollThrottleTimer = null;
      this.resizeDebounceTimer = null;

      this.init();
    }

    private getViewportMode(): ViewportMode {
      const width = window.innerWidth;
      if (width < this.BREAKPOINT_MD) return "mobile";
      if (width < this.BREAKPOINT_LG) return "medium";
      return "desktop";
    }

    private setTriggerState(): void {
      this.triggerEl?.setAttribute(
        "aria-expanded",
        String(!!this.activeSurface)
      );
    }

    private setVisibility(element: HTMLElement, visible: boolean): void {
      element.classList.toggle("is-visible", visible);
      element.setAttribute("aria-hidden", String(!visible));

      if (visible) {
        element.removeAttribute("inert");
      } else {
        const active = document.activeElement as HTMLElement;
        if (active && element.contains(active)) {
          active.blur();
          this.triggerEl?.focus();
        }
        element.setAttribute("inert", "");
      }
    }

    private openSurface(target: Surface): void {
      if (this.activeSurface === target) return;

      if (target === "sidebar") {
        this.setVisibility(this.popoverEl, false);
        this.setVisibility(this.overlayEl, true);
        this.setVisibility(this.panelEl, true);
        document.body.style.overflow = "hidden";
      } else {
        this.setVisibility(this.overlayEl, false);
        this.setVisibility(this.panelEl, false);
        this.setVisibility(this.popoverEl, true);
        document.body.style.overflow = "";
      }

      this.activeSurface = target;
      this.setTriggerState();
    }

    private closeSurface(target: Surface, force = false): void {
      const shouldReset = force || this.activeSurface === target;
      const targetEl = target === "sidebar" ? this.panelEl : this.popoverEl;

      const active = document.activeElement as HTMLElement;
      if (active && targetEl.contains(active)) {
        active.blur();
      }

      if (target === "sidebar") {
        this.setVisibility(this.overlayEl, false);
        this.setVisibility(this.panelEl, false);
        document.body.style.overflow = "";
      } else {
        this.setVisibility(this.popoverEl, false);
      }

      if (shouldReset) {
        this.activeSurface = null;
        this.setTriggerState();
      }
    }

    public closeAll(): void {
      this.closeSurface("sidebar", true);
      this.closeSurface("popover", true);
    }

    private runAction(action: NavMenuAction): void {
      if (action === "open") {
        if (this.mode === "mobile") {
          this.openSurface("sidebar");
        } else if (this.mode === "medium") {
          this.openSurface("popover");
        }
      } else {
        this.closeAll();
      }
    }

    private init(): void {
      const signal = this.abortController.signal;

      window.openNavMenu = () => this.runAction("open");
      window.closeNavMenu = () => this.runAction("close");

      if (window.__navMenuPending) {
        const pending = window.__navMenuPending;
        window.__navMenuPending = null;
        this.runAction(pending);
      }

      this.overlayEl.addEventListener(
        "click",
        (e) => e.target === this.overlayEl && this.closeSurface("sidebar"),
        { signal }
      );

      document.addEventListener(
        "keydown",
        (e) => e.key === "Escape" && this.closeAll(),
        { signal }
      );

      document.addEventListener(
        "click",
        (e) => {
          if (this.mode !== "medium" || this.activeSurface !== "popover")
            return;
          const target = e.target as Node;
          if (this.popoverEl.contains(target)) return;
          if (this.triggerEl?.contains(target)) return;
          this.closeSurface("popover");
        },
        { signal }
      );

      window.addEventListener(
        "scroll",
        () => {
          // Throttle scroll events for better performance
          if (this.scrollThrottleTimer) return;

          this.scrollThrottleTimer = window.setTimeout(() => {
            this.scrollThrottleTimer = null;
            if (this.mode === "medium" && this.activeSurface === "popover") {
              this.closeSurface("popover");
            }
          }, 100);
        },
        { passive: true, signal } as AddEventListenerOptions
      );

      window.addEventListener(
        "resize",
        () => {
          // Debounce resize events to avoid excessive recalculations
          if (this.resizeDebounceTimer) {
            clearTimeout(this.resizeDebounceTimer);
          }

          this.resizeDebounceTimer = window.setTimeout(() => {
            this.resizeDebounceTimer = null;
            const nextMode = this.getViewportMode();
            if (nextMode === this.mode) return;
            this.mode = nextMode;

            if (this.mode === "desktop") {
              this.closeAll();
            } else if (this.mode === "medium") {
              this.closeSurface("sidebar");
            } else {
              this.closeSurface("popover");
            }
          }, 150);
        },
        { signal }
      );

      const handleLinkClick = (surface: Surface) => (e: Event) => {
        const link = (e.target as HTMLElement).closest<HTMLAnchorElement>(
          "a[href]"
        );
        if (link) {
          link.blur();
          setTimeout(() => this.closeSurface(surface), 150);
        }
      };

      this.panelEl.addEventListener("click", handleLinkClick("sidebar"), {
        signal,
      });
      this.popoverEl.addEventListener("click", handleLinkClick("popover"), {
        signal,
      });

      this.closeAll();
    }

    public destroy(): void {
      // Clear any pending timers
      if (this.scrollThrottleTimer) {
        clearTimeout(this.scrollThrottleTimer);
        this.scrollThrottleTimer = null;
      }
      if (this.resizeDebounceTimer) {
        clearTimeout(this.resizeDebounceTimer);
        this.resizeDebounceTimer = null;
      }
      this.abortController.abort();
      this.closeAll();
      delete window.__navMenuController;
    }
  }

  function setupNavMenu() {
    window.__navMenuController?.destroy();

    try {
      window.__navMenuController = new NavMenuController();
    } catch (error) {
      console.error("Failed to initialize nav menu:", error);
      window.__navMenuPending ??= null;
      window.openNavMenu ??= () => {
        window.__navMenuPending = "open";
      };
      window.closeNavMenu ??= () => {
        window.__navMenuPending = "close";
      };
      return;
    }

    if (!window.__navMenuController || window.__navMenuSwupAttached) return;
    window.__navMenuSwupAttached = true;

    const attachSwupHooks = () => {
      if (!window?.swup?.hooks) return;

      window.swup.hooks.on("visit:start", () => {
        window.__navMenuController?.closeAll();
      });

      window.swup.hooks.on("content:replace", () => {
        queueMicrotask(() => setupNavMenu());
      });
    };

    if (window?.swup?.hooks) {
      attachSwupHooks();
    } else {
      document.addEventListener("swup:enable", attachSwupHooks, { once: true });
    }
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", setupNavMenu);
  } else {
    setupNavMenu();
  }
</script>

<style>
  /* Performance optimizations: use GPU-accelerated properties and will-change */
  #nav-menu-overlay {
    z-index: 999;
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
    will-change: opacity;
    transition:
      opacity 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94),
      visibility 0s linear 0.3s;
  }
  #nav-menu-overlay.is-visible {
    opacity: 1;
    visibility: visible;
    pointer-events: auto;
    transition: opacity 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }
  #nav-menu-panel {
    z-index: 9999;
    width: 280px;
    /* Use transform3d for GPU acceleration */
    transform: translate3d(-100%, 0, 0);
    will-change: transform;
    transition: transform 0.35s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    scrollbar-width: none;
    -ms-overflow-style: none;
    /* Use contain for better performance */
    contain: layout style paint;
    box-shadow:
      -10px 0 25px -5px rgba(0, 0, 0, 0.1),
      -10px 0 10px -5px rgba(0, 0, 0, 0.04);
  }
  .dark #nav-menu-panel {
    box-shadow:
      -10px 0 25px -5px rgba(0, 0, 0, 0.3),
      -10px 0 10px -5px rgba(0, 0, 0, 0.2);
  }
  #nav-menu-panel.is-visible {
    transform: translate3d(0, 0, 0);
  }
  /* Remove will-change after animation */
  #nav-menu-panel:not(.is-visible) {
    transition-delay: 0s;
  }
  #nav-menu-panel .nav-link {
    position: relative;
    overflow: hidden;
    /* Prevent layout shifts during hover */
    contain: layout;
  }
  #nav-menu-panel .nav-link::before {
    content: "";
    position: absolute;
    left: 0;
    top: 10%;
    bottom: 10%;
    width: 6px;
    background: var(--primary);
    border-radius: 999px;
    transform: translate3d(-150%, 0, 0);
    transition: transform 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    will-change: transform;
  }
  #nav-menu-panel .nav-link:hover::before,
  #nav-menu-panel .nav-link:focus-visible::before,
  #nav-menu-panel .nav-link:active::before {
    transform: translate3d(0, 0, 0);
  }
  #nav-menu-content::-webkit-scrollbar {
    display: none;
  }
  #nav-menu-popover {
    z-index: 9999;
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
    /* Use transform3d and optimize scale */
    transform: translate3d(0, -12px, 0) scale3d(0.98, 0.98, 1);
    will-change: transform, opacity;
    transition:
      opacity 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94),
      visibility 0s linear 0.2s,
      transform 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    max-height: calc(100vh - 6rem);
    /* Performance optimization */
    contain: layout style paint;
  }
  #nav-menu-popover.is-visible {
    opacity: 1;
    visibility: visible;
    pointer-events: auto;
    transform: translate3d(0, 0, 0) scale3d(1, 1, 1);
    transition:
      opacity 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94),
      transform 0.25s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }
  @media (max-width: 640px) {
    #nav-menu-panel {
      width: 280px;
      max-width: 90vw;
    }
  }

  /* Dark mode acrylic for nav panels */
  :root.dark #nav-menu-panel {
    background-color: rgba(32, 32, 32, 0.78);
  }
  :root.dark #nav-menu-popover {
    background-color: rgba(32, 32, 32, 0.78);
  }

  /* Reduce motion support */
  @media (prefers-reduced-motion: reduce) {
    #nav-menu-overlay,
    #nav-menu-panel,
    #nav-menu-popover,
    #nav-menu-panel .nav-link::before {
      transition-duration: 0.01ms !important;
      animation-duration: 0.01ms !important;
    }
  }
</style>
