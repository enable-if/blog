---
import type { MarkdownHeading } from "astro";
import { siteConfig } from "../../config";
import { url } from "../../utils/url-utils";

interface Props {
  class?: string;
  headings: MarkdownHeading[];
}

let { headings = [] } = Astro.props;

let minDepth = 10;
for (const heading of headings) {
  minDepth = Math.min(minDepth, heading.depth);
}

const className = Astro.props.class;
const isPostsRoute = Astro.url.pathname.startsWith(url("/posts/"));

const removeTailingHash = (text: string) => {
  let lastIndexOfHash = text.lastIndexOf("#");
  if (lastIndexOfHash !== text.length - 1) {
    return text;
  }

  return text.substring(0, lastIndexOfHash);
};

let heading1Count = 1;

const maxLevel = siteConfig.toc.depth;
---

{
  isPostsRoute && (
    <table-of-contents class:list={[className, "group"]}>
      {headings
        .filter((heading) => heading.depth < minDepth + maxLevel)
        .map((heading) => (
          <a
            href={`#${heading.slug}`}
            class="toc-link px-2 flex gap-2 relative transition w-full min-h-9 rounded-xl py-2"
          >
            <div
              class:list={[
                "transition w-5 h-5 shrink-0 rounded-lg text-xs flex items-center justify-center font-bold",
                {
                  "bg-[var(--toc-badge-bg)] text-[var(--btn-content)]":
                    heading.depth == minDepth,
                  "ml-4": heading.depth == minDepth + 1,
                  "ml-8": heading.depth == minDepth + 2,
                },
              ]}
            >
              {heading.depth == minDepth && heading1Count++}
              {heading.depth == minDepth + 1 && (
                <div class="transition w-2 h-2 rounded-[0.1875rem] bg-[var(--toc-badge-bg)]" />
              )}
              {heading.depth == minDepth + 2 && (
                <div class="transition w-1.5 h-1.5 rounded-sm bg-black/5 dark:bg-white/10" />
              )}
            </div>
            <div
              class:list={[
                "transition text-sm min-w-0 break-words [overflow-wrap:anywhere]",
                {
                  "text-50":
                    heading.depth == minDepth || heading.depth == minDepth + 1,
                  "text-30": heading.depth == minDepth + 2,
                },
              ]}
            >
              {removeTailingHash(heading.text)}
            </div>
          </a>
        ))}
      <div
        id="active-indicator"
        style="opacity: 0"
        class:list={[
          { hidden: headings.length == 0 },
          "-z-10 absolute left-0 right-0 rounded-xl transition-all",
        ]}
      />
    </table-of-contents>
  )
}

<style>
  /* TOC link hover - use acrylic instead of solid color */
  table-of-contents .toc-link:hover {
    -webkit-backdrop-filter: blur(8px) saturate(120%);
    backdrop-filter: blur(8px) saturate(120%);
    background-color: rgba(255, 255, 255, 0.25);
  }
  :root.dark table-of-contents .toc-link:hover {
    background-color: rgba(255, 255, 255, 0.06);
  }
  table-of-contents .toc-link:active {
    background-color: rgba(255, 255, 255, 0.4);
  }
  :root.dark table-of-contents .toc-link:active {
    background-color: rgba(255, 255, 255, 0.1);
  }

  /* Active indicator - acrylic effect without border */
  #active-indicator {
    -webkit-backdrop-filter: blur(12px) saturate(150%);
    backdrop-filter: blur(12px) saturate(150%);
    background-color: rgba(255, 255, 255, 0.35);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
  }
  :root.dark #active-indicator {
    background-color: rgba(255, 255, 255, 0.08);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  }
  /* When hovering on TOC, indicator becomes transparent to show item hover instead */
  table-of-contents:hover #active-indicator {
    background-color: transparent;
    -webkit-backdrop-filter: none;
    backdrop-filter: none;
    box-shadow: none;
  }

  /* Active TOC item - text color */
  table-of-contents a.visible > div:last-child {
    color: var(--primary);
  }
  /* Sub-heading dots only - use more specific selector to avoid affecting parent container */
  table-of-contents a.visible > div:first-child > div {
    background-color: var(--primary) !important;
  }
</style>

<script>
  class TableOfContents extends HTMLElement {
    tocEl: HTMLElement | null = null;
    visibleClass = "visible";
    observer: IntersectionObserver;
    anchorNavTarget: HTMLElement | null = null;
    headingIdxMap = new Map<string, number>();
    headings: HTMLElement[] = [];
    sections: HTMLElement[] = [];
    tocEntries: HTMLAnchorElement[] = [];
    active: boolean[] = [];
    activeIndicator: HTMLElement | null = null;
    lastIndicatorTop: number | null = null;
    lastIndicatorHeight: number | null = null;
    lastScrollTargetTop: number | null = null;
    updateScheduled = false;

    constructor() {
      super();
      this.observer = new IntersectionObserver(this.markVisibleSection, {
        threshold: 0,
      });
    }

    markVisibleSection = (entries: IntersectionObserverEntry[]) => {
      entries.forEach((entry) => {
        const id = entry.target.children[0]?.getAttribute("id");
        const idx = id ? this.headingIdxMap.get(id) : undefined;
        if (idx != undefined) this.active[idx] = entry.isIntersecting;

        if (
          entry.isIntersecting &&
          this.anchorNavTarget == entry.target.firstChild
        )
          this.anchorNavTarget = null;
      });

      if (!this.active.includes(true)) this.fallback();
      this.update();
    };

    toggleActiveHeading = () => {
      let i = this.active.length - 1;
      let min = this.active.length - 1,
        max = -1;
      while (i >= 0 && !this.active[i]) {
        this.tocEntries[i].classList.remove(this.visibleClass);
        i--;
      }
      while (i >= 0 && this.active[i]) {
        this.tocEntries[i].classList.add(this.visibleClass);
        min = Math.min(min, i);
        max = Math.max(max, i);
        i--;
      }
      while (i >= 0) {
        this.tocEntries[i].classList.remove(this.visibleClass);
        i--;
      }
      if (min > max) {
        this.activeIndicator?.setAttribute("style", `opacity: 0`);
      } else {
        // Cache rects to avoid repeated layout reads
        const parentRectTop = this.tocEl?.getBoundingClientRect().top || 0;
        const scrollOffset = this.tocEl?.scrollTop || 0;
        const minRect = this.tocEntries[min].getBoundingClientRect();
        const maxRect = this.tocEntries[max].getBoundingClientRect();
        const top = minRect.top - parentRectTop + scrollOffset;
        const bottom = maxRect.bottom - parentRectTop + scrollOffset;
        const height = bottom - top;
        // Only update style when delta is large enough to be visible (avoid layout work churn)
        if (
          this.lastIndicatorTop === null ||
          Math.abs(top - this.lastIndicatorTop) > 1 ||
          this.lastIndicatorHeight === null ||
          Math.abs(height - this.lastIndicatorHeight) > 1
        ) {
          this.activeIndicator?.setAttribute(
            "style",
            `top: ${top}px; height: ${height}px`
          );
          this.lastIndicatorTop = top;
          this.lastIndicatorHeight = height;
        }
      }
    };

    scrollToActiveHeading = () => {
      // If the TOC widget can accommodate both the topmost
      // and bottommost items, scroll to the topmost item.
      // Otherwise, scroll to the bottommost one.

      if (this.anchorNavTarget || !this.tocEl) return;
      const activeHeading = document.querySelectorAll<HTMLDivElement>(
        `#toc .${this.visibleClass}`
      );
      if (!activeHeading.length) return;

      const topmost = activeHeading[0];
      const bottommost = activeHeading[activeHeading.length - 1];
      const tocHeight = this.tocEl.clientHeight;

      let top;
      if (
        bottommost.getBoundingClientRect().bottom -
          topmost.getBoundingClientRect().top <
        0.9 * tocHeight
      )
        top = topmost.offsetTop - 32;
      else top = bottommost.offsetTop - tocHeight * 0.8;

      // Skip if target didn't change significantly
      if (
        this.lastScrollTargetTop === null ||
        Math.abs(top - this.lastScrollTargetTop) > 2
      ) {
        this.lastScrollTargetTop = top;
        this.tocEl.scrollTo({
          top,
          left: 0,
          behavior: "smooth",
        });
      }
    };

    // Coalesce multiple update requests into a single rAF
    update = () => {
      if (this.updateScheduled) return;
      this.updateScheduled = true;
      requestAnimationFrame(() => {
        this.updateScheduled = false;
        this.toggleActiveHeading();
        this.scrollToActiveHeading();
      });
    };

    fallback = () => {
      if (!this.sections.length) return;

      for (let i = 0; i < this.sections.length; i++) {
        const rect = this.sections[i].getBoundingClientRect();
        const offsetTop = rect.top;
        const offsetBottom = rect.bottom;

        if (
          this.isInRange(offsetTop, 0, window.innerHeight) ||
          this.isInRange(offsetBottom, 0, window.innerHeight) ||
          (offsetTop < 0 && offsetBottom > window.innerHeight)
        ) {
          this.markActiveHeading(i);
        } else if (offsetTop > window.innerHeight) break;
      }
    };

    markActiveHeading = (idx: number) => {
      this.active[idx] = true;
    };

    handleAnchorClick = (event: Event) => {
      const anchor = event
        .composedPath()
        .find((element) => element instanceof HTMLAnchorElement);

      if (anchor) {
        const id = decodeURIComponent(anchor.hash?.substring(1));
        const idx = this.headingIdxMap.get(id);
        if (idx !== undefined) {
          this.anchorNavTarget = this.headings[idx];
        } else {
          this.anchorNavTarget = null;
        }
      }
    };

    isInRange(value: number, min: number, max: number) {
      return min < value && value < max;
    }

    connectedCallback() {
      // wait for the onload animation to finish, which makes the `getBoundingClientRect` return correct values
      const element = document.querySelector(".prose");
      if (element) {
        element.addEventListener(
          "animationend",
          () => {
            this.init();
          },
          { once: true }
        );
      } else {
        console.debug("Animation element not found");
      }
    }

    init() {
      this.tocEl = document.getElementById("toc-inner-wrapper");

      if (!this.tocEl) return;

      this.tocEl.addEventListener("click", this.handleAnchorClick, {
        capture: true,
      });

      this.activeIndicator = document.getElementById("active-indicator");

      this.tocEntries = Array.from(
        document.querySelectorAll<HTMLAnchorElement>("#toc a[href^='#']")
      );

      if (this.tocEntries.length === 0) return;

      this.sections = new Array(this.tocEntries.length);
      this.headings = new Array(this.tocEntries.length);
      for (let i = 0; i < this.tocEntries.length; i++) {
        const id = decodeURIComponent(this.tocEntries[i].hash?.substring(1));
        const heading = document.getElementById(id);
        const section = heading?.parentElement;
        if (heading instanceof HTMLElement && section instanceof HTMLElement) {
          this.headings[i] = heading;
          this.sections[i] = section;
          this.headingIdxMap.set(id, i);
        }
      }
      this.active = new Array(this.tocEntries.length).fill(false);

      this.sections.forEach((section) => this.observer.observe(section));

      this.fallback();
      this.update();
    }

    disconnectedCallback() {
      this.sections.forEach((section) => this.observer.unobserve(section));
      this.observer.disconnect();
      this.tocEl?.removeEventListener("click", this.handleAnchorClick);
    }
  }

  if (!customElements.get("table-of-contents")) {
    customElements.define("table-of-contents", TableOfContents);
  }
</script>
